<ol class='xoxo'>

<ol>
  <li>Stateful injective agreement</li>
  <li>Example:</li>
  <li>Learned lesson:  1. The simple idea of checking $end1 \implies end2$ is sound but     could give rise to false attacks. Instead of the /mid/ predicate     we should use correctly the /seq/ predicate to capture the state     dependency between /end1/ and /end2/. As a solution for reaching     $end1 \implies end2$ in stateless protocols it is possible to     insert a dummy $seq(\phi, \phi)$ predicate so that the rules for     /end1/ and /end2/ can be chained.</li>
  <li>Problems with Locks
      <ol>
	<li>Visible intermediate states  1. Locks are too coarse. For example the process:     \[lock(s_1,s_2,s_3); new\ a; out(a); set\ a \in s_1; set\ a \in s_2;\]     would generate:     \[att(a[0,0,x3])\]     \[implies(a[0,0,x3], a[1,0,x3])\]     \[implies(a[1,0,x3], a[1,1,x3])\]     and hence the predicate     \[att(a[1,0,x3])\]     is reachable, although one would like only the final state, namely     \[att(a[1,1,x3])\]     to be visible from the outside.</li>
	<li>Set-abstraction multi-value interleavings  1. For the set abstraction, one of the problems is the locality of the states in transitions     \[att(sign(xm[x1,x2,x3],xc[0],k[])) \implies implies(xm[x1,x2,x3],xm[x1,1,x3])\]     \[att(sign(xm[x1,x2,x3],xc[0],k[])) \implies implies(xc[0],xc[1])\]</li>
      </ol>
  </li>
</ol>
</li>
</ol>
