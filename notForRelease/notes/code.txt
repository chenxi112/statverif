pitsyntax.ml: Typed proverif file - extension .pv

parsing file: done in pisyntax.ml, line 2209.

Starts by initialising the environment in 
initialys_env_and_fun_decl (pitsyntax.ml, line 146)
then calls the parser, resulting in a parse tree
then calls check_process: (pitsyntax.ml, line 1557)checks well-formedness of process and
transofrms it into proper syntax
check_term: (pitsyntax.ml, line  911)

Processing for secrecy untyped:
- first parse file,
- then for each query dod (line 690:)
- display query
- call Piauth.solve_auth to do the real work
- now, do completion
- then: do_query:
- calls check_query:
        checks whether query is true (query_goal_std)
- calls clauses_match: checks whether clause is satisfied
- calls display_clause_trace:
       - prints cluase
- calls Histroy.build_history       





Initial processing for typed equivalence: after reading the process, first function called
is

Rules.bad_derivable rulelist

Simplify.prepare_process



(* Prepare a process by choosing new identifiers for names, variables *)
Simplify.prepare_process: 
first clears global hash table
then calls Terms.auto_cleanup, which applies a function f (in this
case, resetting occurrences and chossing new identifiers)
then setting a few parameters (including weaksecret_mode to true), 
and calling Pitranslweak.transl to obtain the rules


Pitranslweak.transl (line 1678)
first calls find_min_choice_phase 0 p (line 51) 

then generates all clauses for attacker (transl_attacker), line 1420


Pitranslweak.transl_process (line 547): argument cur_state process

input case (line 884): first call to freshen_cells,
then trans_term_incl_destructor.





find_same_format: checks whether the fact occurs in the set, and
returns the weight of the fact. (normally a nounif-fact).

matchafactstrict finst fgen


compute_match_format: replaces two variables with FAny v1, and
(variable, anything else) by FVar v1

format_equal_fact: links no_unif variable to variable of hypothesis
via VLink


trans_term_incl_destructor (line 386):
first checks for several patterns via
Reduction_helper.transl_check_several_patterns. Does nothing.
Then calls trans_term (line 295)

find_same_format: creates tlink

is_unselectable: Out facts, blocking facts, or tuples with only
variables as arguments. Example attacker2(x_1,...,x_n)

sel_function_weight hyp concl works as follows:
- first try to select hypothesis
- don't seelct hypotehsis if it matches nounif, or is unselectable, or
conclusion is instance of hypothesis
-1 means: conclusion selected

(* [compos] unifies [concl1] with the selected hypothesis of [hyp2]
   and builds the resulting rule 
   There must be no selected fact in [rule1], and a selected fact in [rule2]

   R = F1 & ... & Fn -> F0
   R' = F'1 & ... & F'n' -> F'0
can be composed into
      s F1 & ... & s Fn & s F'2 & ... & s F'n -> s F'0
where s is the most general unifier of F0 and F'1
if 
    F'1 selected 
and for all Fi, Fi not selected


----------

complete_rules: 
Immediately calls 









Main process:




Links: format_equal creates link 

normal_rule: normalises the rule base. Composed of several functions:

decompose_hyp_tuples2: immediately calls decompose_hyp_tuples 

decompse_hyp_tuples: If rule hasn't been application of tuples,
eliminate double hypotheses. For all attacker-hypothesis, if first
non-state argument is tuple, then history is modified.

next one: simp_eq_rule: apply equational theory to hypotheses and
conclusions

next one:
elim_not: eliminates hypotheses with a "not" fact.  used for
secrecy. Idea: if not-fact is derivable, we have failed anyway.

weak


decompose_concl_tuples:
Decomposes tuples.

elim_taut: eliminates tautologies
elim_any_x2: eliminates attacker(x1, ..., xn) if x1,..,xn don't occur
elsewhere

simplify_constraints: performs unification between terms of each
constraint, and replaces terms by unifiers

elem_simplify: only done whem memberOptim is set
elim_redundant_hypotheses: eliminate redundant hypotheses
 

Preservation of elimination of superfluous rules:
decompose_hyp_rec: will not lose superfluous rules.
simp_eq_rule: will not lose superfluous rules
decompose_concl_tuples: will not lose superfluous rules
elim_taut: will not lose superfluous rules
elim_any_x2: will not lose superfluous rules
smiplify_constraints: will lose superfluous rules
elem_simplify: will not lose superfluous rules (normally not done)
elem_simplify2: will not lose superfluous rules (normally not done)
eim_redundant_hypotheses: will not lose superfluous rules

new s - translation:

first step: create name with no previous inputs in Terms.create_name


authentication: in piauth.ml
key function: solve_auth, does first completion, then calls 
 do_query.

do_query effectively calls check_query

check_query: calls Rules.query_goal_std



Have two different labels:

Types.label: label of rule
Types.hypspec: labels of hypotheses

Pitransl.add_rule adds Rule(!nrule, Types.label,...)
Resolution constructs tree with Resolution(hist1, sel_index, hist2) 

History.build_history constructs the history.
data structures for history: Types.history (stored in the rule,
keeping track of resolution steps). Important constructors: Rule and Resolution.

build_history: cnstructs Types.fact_tree with condensed version of
history

Result: FRule with every hypothesis eliminated by resolution replaced
with another instance of FRule

FRule: description for each hypothesis of the rule set to empty.


simplify_tree: removes hypothesis we have seen before and replaces
FRule with FRemovedWithProof

Display.Text.explain_history_tree: displays the history


Branches: transitivity: transitivity of state relation added.
