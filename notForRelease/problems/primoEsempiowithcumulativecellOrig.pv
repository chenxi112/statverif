(* First example for secure boot device code *)

(* A secure boot device *)

type key.

query attacker(sfk).

(* constant values *)
fun uno():bitstring.
fun due():bitstring.
fun tre():bitstring.
fun quattro():bitstring.

(* request labels *)
fun getvfk():bitstring.
fun getvk():bitstring.
fun getvkcert():bitstring.
fun getbtlcert():bitstring.
fun getbtl():bitstring.

(* certificates tags *)
fun newvk():bitstring.
fun btl():bitstring.

(* crypto functions *)
fun sign(key,bitstring):bitstring.
fun pk(key):key.

(*fun aenc(key,channel):bitstring.*)

fun h(key):key.
fun h2(bitstring):bitstring.

free c:channel.

free sfk: key [private].

(* signature verification *)
reduc forall k:key,m:bitstring; checksign(pk(k),sign(k,m)) = m.
(*reduc forall k:key,xch:channel; adec(k,aenc(pk(k),xch)) = xch.*)

(* memory initialisation values *)
free initsk: key [private].
free initbtl: bitstring [private].
free genid:bitstring [private].

(* memory cells *)
(*cell mbtl: bitstring := (initbtl).   bootloader *)
(*cell mvk: key := pk(initsk).         vk *)
(*cell mp: bitstring := uno.           p *)
(*cell mvfk:key.                       vfk *)
(*cell mvkcert:bitstring.              vk certificate *)
(*cell mbtlcert: bitstring.            bootloader certificate *)

cell memory: bitstring := (pk(sfk),pk(initsk),uno,sign( sfk, (newvk, genid, pk(initsk), uno)),sign( initsk, (btl, h2(initbtl))),initbtl).

(* bitmap *)
cell B1:bool := true.
cell B2:bool := true.
cell B3:bool := true.
cell B4:bool := true.
cell B5:bool := true.
cell B6:bool := true.

let BootRom(hvfk:key) =
   out(c, getvfk);
   in (c, vfk:key);
   if hvfk = h(vfk) then
     (
      out(c, getvk);
      in(c, (vk:key,p:bitstring));
      out(c, getvkcert);
      in(c, vkcert:bitstring);
      let (tag:bitstring, genid':bitstring, vk':key, p':bitstring) = checksign(vfk, vkcert) in 
         if tag = newvk && genid' = genid && vk'=vk && p = p' then 
            if p = uno then (* LaunchBtl(B1,vk) *)
            (   lock(B1);
                read B1 as B; 
       		if B then
          	out(c, getbtlcert);
	        in(c, btlcert:bitstring);
        	out(c, getbtl);
          	in(c, currentbtl:bitstring);
          	let (l:bitstring, hbtl:bitstring) = checksign(vk,btlcert) in
              		if l=btl && hbtl=h2(currentbtl) then unlock(B1)
            )
            else if p = due then (* LaunchBtl(B2,vk) *)
            (   lock(B2);
                read B2 as B; 
       		if B then
          	out(c, getbtlcert);
	        in(c, btlcert:bitstring);
        	out(c, getbtl);
          	in(c, currentbtl:bitstring);
          	let (l:bitstring, hbtl:bitstring) = checksign(vk,btlcert) in
              		if l=btl && hbtl=h2(currentbtl) then unlock(B2)
            )
            else if p = tre then (* LaunchBtl(B3,vk)*)
            (   lock(B3);
                read B3 as B; 
       		if B then
          	out(c, getbtlcert);
	        in(c, btlcert:bitstring);
        	out(c, getbtl);
          	in(c, currentbtl:bitstring);
          	let (l:bitstring, hbtl:bitstring) = checksign(vk,btlcert) in
              		if l=btl && hbtl=h2(currentbtl) then unlock(B3)
            )
            else if p = quattro then (* LaunchBtl(B4,vk)   *)
            (   lock(B4);
                read B4 as B; 
       		if B then
          	out(c, getbtlcert);
	        in(c, btlcert:bitstring);
        	out(c, getbtl);
          	in(c, currentbtl:bitstring);
          	let (l:bitstring, hbtl:bitstring) = checksign(vk,btlcert) in
              		if l=btl && hbtl=h2(currentbtl) then unlock(B4)
            )
      ).
    
(*let LaunchBtl(bitmap:cell,vk:key) =
    lock(bitmap);
    read bitmap as B; 
       if B then
          out(c, getbtlcert);
          in(c, btlcert:bitstring);
          out(c, getbtl);
          in(c, currentbtl:bitstring);
          let (l:bitstring, hbtl:bitstring) = checksign(vk,btlcert) in
              if l=btl && hbtl=h2(currentbtl) then unlock(bitmap). *)


let Mem = in(c, request:bitstring);
   if request = getvfk then
      (
       lock(memory);
       read memory as M;
       let (mvfk:key, mvk:key, mp:bitstring, mvkcert:bitstring, mbtlcert:bitstring, mbtl:bitstring) = M in 
       out(c, mvfk);
       unlock(memory)
      )
   else if request = getvkcert then
      (
       lock(memory);
       read memory as M;
       let (mvfk:key, mvk:key, mp:bitstring, mvkcert:bitstring, mbtlcert:bitstring, mbtl:bitstring) = M in 
       out(c, mvkcert);
       unlock(memory)
      )
   else if request = getvk then
      (
       lock(memory);
       read memory as M;
       let (mvfk:key, mvk:key, mp:bitstring, mvkcert:bitstring, mbtlcert:bitstring, mbtl:bitstring) = M in 
       out(c, (mvk, mp));
       unlock(memory)
      )
   else if request = getbtl then
      (
       lock(memory);
       read memory as M;
       let (mvfk:key, mvk:key, mp:bitstring, mvkcert:bitstring, mbtlcert:bitstring, mbtl:bitstring) = M in 
       out(c, mbtl);
       unlock(memory)
      )
   else if request = getbtlcert then
      (
       lock(memory);
       read memory as M;
       let (mvfk:key, mvk:key, mp:bitstring, mvkcert:bitstring, mbtlcert:bitstring, mbtl:bitstring) = M in 
       out(c, mbtlcert);
       unlock(memory)
      ).
 

process
  (
  new sfk:key;
  let vfk=pk(sfk) in 
      !(BootRom(h(vfk)))) | !(Mem)
         
   



