(* First example for secure boot device code *)

(* A secure boot device *)

type key.

query attacker(sfk).

(* constant values *)
fun uno():bitstring.
fun due():bitstring.
fun tre():bitstring.
fun quattro():bitstring.

(* request labels *)
fun getvfk():bitstring.
fun getvk():bitstring.
fun getvkcert():bitstring.
fun getbtlcert():bitstring.
fun getbtl():bitstring.

(* certificates tags *)
fun newvk():bitstring.
fun btl():bitstring.

(* crypto functions *)
fun sign(key,bitstring):bitstring.
fun pk(key):key.

(*fun aenc(key,channel):bitstring.*)

fun h(key):key.
fun h2(bitstring):bitstring.

free c:channel.

free sfk: key [private].

(* signature verification *)
reduc forall k:key,m:bitstring; checksign(pk(k),sign(k,m)) = m.
(*reduc forall k:key,xch:channel; adec(k,aenc(pk(k),xch)) = xch.*)

(* memory initialisation values *)
free initsk: key [private].
free initbtl: bitstring [private].
free genid: bitstring [private].
free initkey: key [private].
free initsig1: bitstring [private].
free initsig2: bitstring [private].
(* memory cells *)
cell mbtl: bitstring := (initbtl).  (* bootloader *)
cell mvk: key := pk(initsk).        (* vk *)
cell mp: bitstring := uno.          (* p *)
cell mvfk:key:=initkey.                      (* vfk *)
cell mvkcert:bitstring:=initsig1.             (* vk certificate *)
cell mbtlcert: bitstring:=initsig2.           (* bootloader certificate *)

(* bitmap *)
cell B1:bool := true.
cell B2:bool := true.
cell B3:bool := true.
cell B4:bool := true.


let BootRom(hvfk:key,genid:bitstring) =
   out(c, getvfk);
   in (c, vfk:key);
   if hvfk = h(vfk) then
     (
      out(c, getvk);
      in(c, (vk:key,p:bitstring));
      out(c, getvkcert);
      in(c, vkcert:bitstring);
      let (tag:bitstring, genid':bitstring, vk':key, p':bitstring) = checksign(vfk, vkcert) in
         if tag = newvk && genid' = genid && vk'=vk && p = p' then
            if p = uno then (* LaunchBtl(B1,vk) *)
            (   lock(B1);
                read B1 as B; 
       		if B then
          	out(c, getbtlcert);
	        in(c, btlcert:bitstring);
        	out(c, getbtl);
          	in(c, currentbtl:bitstring);
          	let (l:bitstring, hbtl:bitstring) = checksign(vk,btlcert) in
              		if l=btl && hbtl=h2(currentbtl) then out(c,sfk);unlock(B1)
            )
            else if p = due then (* LaunchBtl(B2,vk) *)
            (   lock(B2);
                read B2 as B; 
       		if B then
          	out(c, getbtlcert);
	        in(c, btlcert:bitstring);
        	out(c, getbtl);
          	in(c, currentbtl:bitstring);
          	let (l:bitstring, hbtl:bitstring) = checksign(vk,btlcert) in
              		if l=btl && hbtl=h2(currentbtl) then unlock(B2)
            )
            else if p = tre then (* LaunchBtl(B3,vk)*)
            (   lock(B3);
                read B3 as B; 
       		if B then
          	out(c, getbtlcert);
	        in(c, btlcert:bitstring);
        	out(c, getbtl);
          	in(c, currentbtl:bitstring);
          	let (l:bitstring, hbtl:bitstring) = checksign(vk,btlcert) in
              		if l=btl && hbtl=h2(currentbtl) then unlock(B3)
            )
            else if p = quattro then (* LaunchBtl(B4,vk)   *)
            (   lock(B4);
                read B4 as B; 
       		if B then
          	out(c, getbtlcert);
	        in(c, btlcert:bitstring);
        	out(c, getbtl);
          	in(c, currentbtl:bitstring);
          	let (l:bitstring, hbtl:bitstring) = checksign(vk,btlcert) in
              		if l=btl && hbtl=h2(currentbtl) then unlock(B4)
            )
      ).
    
(*let LaunchBtl(bitmap:cell,vk:key) =
    lock(bitmap);
    read bitmap as B; 
       if B then
          out(c, getbtlcert);
          in(c, btlcert:bitstring);
          out(c, getbtl);
          in(c, currentbtl:bitstring);
          let (l:bitstring, hbtl:bitstring) = checksign(vk,btlcert) in
              if l=btl && hbtl=h2(currentbtl) then unlock(bitmap). *)


let Mem = in(c, request:bitstring);
   if request = getvfk then
      (
       lock(mvfk);
       read mvfk as vfk; 
       out(c, vfk);
       unlock(mvfk)
      )
   else if request = getvkcert then
      (
       lock(mvkcert);
       read mvkcert as vkcert; 
       out(c, vkcert);
       unlock(mvkcert)
      )
   else if request = getvk then
      (
       lock(mvk);
       lock(mp);
       read mvk as vk;
       read mp as p; 
       out(c, (vk, p));
       unlock(mvk);
       unlock(mp)
      )
   else if request = getbtl then
      (
       lock(mbtl);
       read mbtl as currentbtl; 
       out(c, currentbtl);
       unlock(mbtl)
      )
   else if request = getbtlcert then
      (
       lock(mbtlcert);
       read mbtlcert as btlcert; 
       out(c, btlcert);
       unlock(mbtlcert)
      ).
 

process
  (
  (* new sfk:key; *)
  lock(mvfk);
  lock(mvkcert);
  lock(mbtlcert);
  mvfk := pk(sfk);
  mvkcert := sign( sfk, (newvk, genid, pk(initsk), uno));
  mbtlcert := sign( initsk, (btl, h2(initbtl)));
  unlock(mvfk); 
  unlock(mvkcert);
  unlock(mbtlcert);
  let vfk=pk(sfk) in 
      !(BootRom(h(vfk),genid))) | !(Mem)
         
   



