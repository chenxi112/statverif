set verboseCompleted = true.

type key.
fun sign(bitstring, key): bitstring.
reduc forall x:bitstring, k: key; checksign(sign(x, k), k) = x.
reduc forall x:bitstring, k: key; getmsg(sign(x, k)) = x.

channel ch.

free K: key [private].
free L: key [private].
free zero: bitstring [private].

event gate_open(bitstring,bitstring).
event gate_debit(bitstring).
event card_permit(bitstring,bitstring).
event card_add(bitstring).

query x:bitstring,y:bitstring; inj-event(card_permit(x,y)) ==> event(card_add(x)).
(*query x:bitstring,y:bitstring; inj-event(gate_open(x,y)) ==> event(gate_debit(x)).*)
query x:bitstring,y:bitstring; inj-event(card_add(x)) ==> event(gate_debit(x)).

cell s : bitstring := (zero, zero).

let gate =
  ( !
    new n: bitstring;
    out(ch, n);
    in(ch, z : bitstring);
    let (x:bitstring, =n) = checksign(n, K) in
    event gate_open(x, n)
  ) | ( !
    in(ch, x_m : bitstring);
    event gate_debit(x_m);
    out(ch, sign(x_m, L))
  ).

let card =
  ( !
    lock s;
    in(ch, y: bitstring);
    read s as (s_1: bitstring, s_2: bitstring);
    if s_2 <> zero then
       event card_permit(s_2, y);
       s := (s_1, zero);
       out(ch, sign((s_2, y), K))
    else if s_1 <> zero then
       event card_permit(s_1, y);
       s := (zero, zero);
       out(ch, sign((s_1, y), K))
  ) | ( !
    lock s;
    new m: bitstring;
    out(ch, m);
    in(ch, x_s: bitstring);
    if x_s = sign(m, L) then
    read s as (s_1: bitstring, s_2: bitstring);
    if s_1 = zero then
       event card_add(m);
       s := (m, zero)
    else if s_2 = zero then
       event card_add(m);
       s := (s_1, m)
  ).

process (gate | card)
